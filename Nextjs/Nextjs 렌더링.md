
### 1. CSR

- 최소한의 html에 스크립트를 링크한다
	- 링크된 스크립트에는 리액트, 기타 의존성 등 모든 애플리케이션 코드가 포함된다 → 번들 크기 커짐
	- ===js가 다운로드 및 구분분석하기까지 사용자는 빈화면===을 봐야했다.
- 초기 ui가 표시되더라도 콘텐츠는 여전히 누락되어있어 로딩 스켈레톤이 인기를 얻음
- 그 다음 데이터를 가져오고 ui가 두번째로 렌더링 되어 실제 콘텐츠가 렌더링된다.

### 2. SSR

- 사용자에게 제공된 html은 비어있지않고, 초기 ui를 빠르게 보여줄 수 있다.
- 그러나 상호작용이나 실제 콘텐츠가 표시되려면 여전히 데이터를 불러와야했다. (hydrate 및 fetch)
- **초기에 인터렉션은 불가능하지만 정적인 HTML을 빠르게 내려주는데 초점**
- 따라서 초기에 HTML이 로딩된 이후에는 클라이언트에서 JS를 다운, 파싱, 실행 비용이 발생한다
- _빌드중에 동적 데이터를 캐시하고 렌더링하는 ssg나 필요에따라 데이터를 다시 캐시하고 렌더링하는 isr이 도입된다_

### 3. RSC (React Server Component, 렌더링 환경)

- **서버에서만 렌더링**되고, 그 결과는 html과 함께 스트리밍되어 클라이언트로 전송
- 사용자에게 제공되는 html은 첫번째 렌더링 시 실제 콘텐츠로 완전히 채워진다
- 즉, 추가데이터를 가져오거나 추가 렌더링이 필요없다. (성능이 크게 발전)
- React Client Component는 기존의 컴포넌트와 동일 (클라이언트에서 js를 받고 실행)
    1. 브라우저와 상호작용이 필요하거나, 이벤트 리스너(onClick(), onChange() 등)가 필요할 때
    2. 상태 및 라이프사이클 효과(useState(), useReducer(), useEffect() 등), 즉 react hook을 사용할 때
    3. 브라우저 전용 API를 사용할 때 (window, document..)
    4. React 클래스 컴포넌트를 사용할 때
- 서버사이드 렌더링과 서버컴포넌투눈 대체재가 아니라 상호보완의 개념으로 봐야한다
    - 미래에는 두가지를 혼용할 수 있음:
        - 서버 컴포넌트를 활용해 서버에서 렌더링 할 수 있는 컴포넌트는 서버에서 완성
        - 클라인언트 컴포넌트는 서버사이드 렌더링으로 초기 HTML을 빠르게 전달
    - 이렇게 두 방식을 결합하면 클라이언트 서버컴포넌트를 모두 빠르게 보여줄 수 있고, 동시에 클라이언트에서 내려받는 js의 양도 줄어 브라우저 부담이 줄어든다.
- 기존의 ssg, isr (getStaticProps)방식은 fetch API의 캐시 옵션을 통해 사용 가능