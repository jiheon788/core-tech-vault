
# Nextjs 렌더링
### 1. CSR
- 브라우저가 서버로부터 ==비어있는 뼈대 HTML을 받아온 후, 필요한 자바스크립트 번들을 다운로드하고 번들을 실행하여 동적으로 컨텐츠를 채우는 방식==
- 최소한의 html에 스크립트를 링크한다
	- 링크된 스크립트에는 리액트, 기타 의존성 등 모든 애플리케이션 코드가 포함된다 → 번들 크기 커짐
	- ===js가 다운로드 및 구분분석하기까지 사용자는 빈화면===을 봐야한다.
- 초기 ui가 표시되더라도 콘텐츠는 여전히 누락되어있어 로딩 스켈레톤이 인기를 얻음
- 그 다음 데이터를 가져오고 ui가 두번째로 렌더링 되어 실제 콘텐츠가 렌더링된다.

### 2. SSR

- 사용자에게 제공된 html은 비어있지않고, 초기 ui를 빠르게 보여줄 수 있다.
- ==정적인 html을 내려주어 초기 화면을 빠르게 렌더한 이후, hydration을 통해 이벤트 리스너 부착 등의 자바스크립트 작업을 수행하여 정적인 화면을 동적으로 전환하는 작업==을 수행
- ==**초기에 인터렉션은 불가능하지만 정적인 HTML을 빠르게 내려주는데 초점**==
- 따라서 초기에 HTML이 로딩된 이후에는 클라이언트에서 JS를 다운, 파싱, 실행 비용이 발생한다
- _SSG는 빌드 시점에 데이터를 가져와 정적인 HTML을 생성하고 캐싱하며, ISR은 SSG처럼 정적인 HTML을 제공하지만, 필요할 때 백그라운드에서 데이터를 갱신하여 다시 캐싱하는 방식이다._

### 3. RSC (React Server Component, 렌더링 환경)

- **서버에서만 렌더링**되고, 그 결과는 html과 함께 스트리밍되어 클라이언트로 전송
- 사용자에게 제공되는 html은 첫번째 렌더링 시 실제 콘텐츠로 완전히 채워진다
- 즉, 추가데이터를 가져오거나 추가 렌더링이 필요없다. (성능이 크게 발전)
- React Client Component는 기존의 컴포넌트와 동일 (클라이언트에서 js를 받고 실행)
    1. 브라우저와 상호작용이 필요하거나, 이벤트 리스너(onClick(), onChange() 등)가 필요할 때
    2. 상태 및 라이프사이클 효과(useState(), useReducer(), useEffect() 등), 즉 react hook을 사용할 때
    3. 브라우저 전용 API를 사용할 때 (window, document..)
    4. React 클래스 컴포넌트를 사용할 때
- 기존의 ssg, isr (getStaticProps) 렌더링은 fetch API의 캐시 옵션을 통해 사용 가능

>[!tip]
>SSR과 RSC는 대체재가 아니라 상호보완의 개념으로 봐야한다
>- 미래에는 두가지를 혼용할 수 있음:
>	- 서버 컴포넌트를 활용해 서버에서 렌더링 할 수 있는 컴포넌트는 서버에서 완성
>	- 클라인언트 컴포넌트는 서버사이드 렌더링으로 초기 HTML을 빠르게 전달
>	- 이렇게 두 방식을 결합하면 클라이언트 서버컴포넌트를 모두 빠르게 보여줄 수 있고, 동시에 클라이언트에서 내려받는 js의 양도 줄어 브라우저 부담이 줄어든다.

### RSC 작동 순서

1. 서버가 렌더링 요청을 받는다
    - 서버가 렌더링 과정을 수행해야 하기에 리액트 서버 컴포넌트를 사용하는 모든 페이지는 항상 서버에서 시작 (루트 컴포넌트는 항상 서버컴포넌트)
2. 서버는 받은 요청에 따라 컴포넌트를 JSON으로 직렬화 (serialize)
    - 서버에서 렌더링할 수 있는 것은 직렬화해서 내보냄
    - 클라이너트 컴포넌트의 공간을 플레이스 홀더 형식으로 비워두고 나타낸다
    - 브라우저는 이결과물을 받아서 다시 역질렬화한다음 렌더링을 수행한다.
3. 브라우저가 리액트 컴포넌트 트리를 구성한다.
    - 서버로부터 json 결과물을 받았다면 구문을 다시 파싱한 결과물을 바탕으로 트리를 재구성해 컴포넌트를 만든다
    - 클라이언트 컴포넌트를 받으면 클라이언트에서 렌더링 진행
    - 서버에서 만들어진 결과물을 받았다면 이 정보를 기반으로 리액트 트리를 그대로 만든다
    - 최종적으로 트리를 렌더링해 브라우저의 DOM에 커밋한다.


>[!tip]
위와 같은 작동방식으로 인해 **서버컴포넌트에서 클라이언트 컴포넌트로 props를 넘길 때 반드시 직렬화 가능한 데이터를 넘겨야 한다.** 서버에서 클라이언트로 데이터를 보내는 것은 json을 통해 이루어지기 때무에 json으로 직렬화가 할 수 없는 데이터(class, Date 등) 는 넘겨줄 방법이 없다.

### RSC RCC 중첩 구조

RCC에서 RSC를 렌더링할 수는 없다. 왜냐하면 클라이언트 컴포넌트가 서버 컴포넌트를 실행할 방법이 없기 떄문이다. (서버 환경이 브라우저에는 존재하지 않는다.)

==대신 자식으로 RSC를 가지는 구조는 가능==하다.

클라이언트 입장에서 봤을 때, 서버컴포넌트는 이미 서버에서 만들어진 트리를 가지고 있다. 클라이언트 컴포넌트는 만들어진 트리를 삽입해서 보여주기만 하면 되기 떄문이다. 따라서 서버컴포넌트와 클라이언트 컴포넌트를 중첩해서 가지는 구조가 가능하다.