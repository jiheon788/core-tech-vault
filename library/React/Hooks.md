React Hooks는 **함수형 컴포넌트에서 상태(state)와 생명주기(lifecycle) 기능을 사용할 수 있도록 해주는 기능**이다. Hook를 이용하여 기존 클래스 컴포넌트 기반의 코드 작성 없이 state와 라이프사이클을 다룰 수 있게됐다.

**기존 클래스 컴포넌트의 문제**
- 복잡한 컴포넌트 구조
	- 같은 로직이 여러 생명주기 메서드(`componentDidMount`, `componentDidUpdate` 등)에 분산됨.
	- 유지보수가 어렵고, 중복 코드 발생
- 컴포넌트 간 상태 공유/재사용 어려움
	- HOC, Render Props 같은 패턴 사용해야함
	- 코드가 복잡해지고 가독성이 떨어진다.

==Hook을 사용하면 컴포넌트로부터 상태 관련 로직을 추상화할 수 있고, 선언적인 방식으로 직관적인 코드 작성을 돕는다.==

##### useState
- 값을 저장하기 위해 사용 [[React의 상태 (State)]]
- 리렌더링을 유발
- **[[클로저]]를 활용하여 상태를 유지하고 업데이트**
	- 컴포넌트가 렌더링될 때마다 새로운 클로저를 생성하여 상태 유지
	- 클로저 내부에서 이전 상태를 기억하고 새로운 값으로 업데이트
##### useRef
- 값을 저장하기 위해 사용
- 리렌더링 유발하지 않음
- 주로 DOM 참조나 값의 지속적 유지에 사용
>[!tip]
>**함수형 컴포넌트에서 ref가 바로 전달되지 않는이유**
>함수형 컴포넌트는 인스턴스가 없어서, ref를 직접 전달할 수 없다. 즉, 클래스 컴포넌트처럼 자신의 참조를 가질 수 있는 객체가 없기 때문이다. 그래서 ref를 전달하려면 forwardRef를 사용해 직접 전달해줘야 합니다.

##### useEffect
- **렌더링이 완료되는 시점**에 **비동기적**으로 실행 (화면이 실제로 사용자에게 그려진 후)
- 렌더링 후에 실행되며 특정 값이 변경될 때 실행되도록 설정 가능
- 외부 시스템과 컴포넌트 동기화할 떄 사용한다.
	- state를 기준으로 리액트와 상관 없는 구성요소 제어
	- 데이터를 가져오는 작업이나 이벤트 리스너 추가 등 **렌더링 후에 화면에 직접적인 영향을 주지 않는 작업**

##### useLayoutEffect
- **렌더링 후 DOM이 업데이트되기 직전의 시점**에 **동기적**으로 실행 -> 화면에 내용이 그려지기 전에 모든 레이아웃 관련 작업이 완료
- **요소의 크기를 측정**하거나 **위치를 조정해야 할** 때 `useLayoutEffect`를 사용하면 즉각적으로 그 변경사항이 반영되어 화면 깜빡임이나 불필요한 재렌더링을 방지
- 동기적으로 실행되기 때문에 너무 많은 작업이 실행되면 렌더링이 느려질 수 있음

>[!tip]
>**useEffect, useLayoutEffect 순서**
>1. 렌더링: 컴포넌트 실행 -> 가상 DOM 생성
>2. useLayoutEffect 실행: DOM이 업데이트 된 직후, 화면이 그려지기 전에 실행
>3. 화면 그리기: 브라우저가 변경된 내용 화면에 표시
>4. useEffect 실행: 화면이 그려진 후에 실행


### useCallback, useMemo, React.memo의 차이
useCallback, useMemo, React.memo는 렌더링을 최소한으로 줄이기 위한 훅

- useMemo: 값 재계산 방지.
- useCallback: 함수 재생성 방지.
	- JS에서는 함수가 일급객체라 useMemo를 동일하게 사용할 수 있지만 명시적 분리를 위해 따로 존재
- React.memo: 컴포넌트가 동일한 props를 받으면 리렌더링을 방지
    - 객채타입을 props로 넘기면 커스텀 비교함수를 작성하는 것이 좋다. shallow 비교방식을 사용하는데 커스텀 비교함수 안넣으면 메모이제이션하는 의미가 없음