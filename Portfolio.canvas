{
	"nodes":[
		{"id":"7f663221f77e8e83","type":"text","text":"### 이마고웍스 - 코드 파편화로 인한 유지보수의 어려움을 개선하기 위해 레거시 코드 리팩토링\n\n##### 상황:\n- 서버데이터와 클라이언트 데이터의 혼용\n- 한 프로젝트에서 react-query, redux, recoil, context 등 여러 상태관리 혼용\n\n##### 문제:\n- **일관성 부족**: 서버 데이터와 클라이언트 데이터를 혼용하면서 데이터 동기화가 어려워짐.\n- **복잡한 상태 관리**: 여러 상태 관리 라이브러리를 사용하면서 코드가 복잡해지고 유지보수가 어려워짐.\n- **예측 가능성 저하**: 특정 데이터가 어디에서 관리되고 있는지 파악하기 어려워 디버깅이 어려움.\n\n##### 해결:\n- React-Query를 서버 상태 관리, \n- Recoil을 클라이언트 상태 관리에 집중적으로 활용하여 역할을 분리\n\t- 리코일의 쉬운 사용법과 리액트 팀에서 공식으로 만든 라이브러리이기에 채택\n\t- 쉬운 사용법은 장점이긴 하나 상태 변경 로직을 언제 어디서든 쉽게 가져다 쓸 수 있기에 여러 사람이 협업할 때 예측이 어려움\n\t\t- 이를 개선하기 위해 hooks를 거치도록 레이어를 설계\n\t\t- 전역상태의 무분별한 변경으로 인해 디버깅과 예측이 힘들어지는 것을 방지하고, 상태 변경 로직을 한 곳에 모아두기 위함\n\n##### 평가:\n- **눈에 띄게 적어진 코드량과 낮은 러닝커브** 덕분에 생산성을 올려줌\n- **디버깅 용이**: 데이터 흐름이 명확해지고, 어디에서 상태가 변경되는지 쉽게 추적 가능.","x":160,"y":-300,"width":580,"height":880,"color":"3"},
		{"id":"2f7e9ba9e62d0666","type":"file","file":"library/Tanstack Query.md","x":1320,"y":-260,"width":580,"height":400},
		{"id":"62bc4b8ebec6808b","type":"file","file":"JavaScript/For Loop vs Higher Order Functions.md","x":1320,"y":-1360,"width":580,"height":400},
		{"id":"0c3733d8aceb6c09","type":"file","file":"JavaScript/Mutation의 개념과 활용.md","x":1320,"y":-850,"width":580,"height":400},
		{"id":"e31d1d970ed7aa2a","type":"file","file":"assets/박지헌_Resume_250131.pdf","x":-1180,"y":-660,"width":485,"height":660,"color":"6"},
		{"id":"2a54a434b38a6be5","type":"text","text":"#  성능최적화\n\n- 가상스크롤링\n- 초기로딩속도개선\n\t- 상호작용 시 불러오기\n\t- 트리쉐이킹\n\n최적화를 통해 얻을 수 있는 이점 ? -> 더 나은 사용자 경험과 SEO -> \n좋은 사용자 경험은 무엇일까? -> 사용자가 목적을 직관적이고 빠르게 달성\n\n\n최적화 원칙\n- 조기 최적화는 지양, 모든 최적화는 트레이드오프가 따른다.\n- 가장 좋은 코드는 실행되지 않는 코드다","x":160,"y":2320,"width":625,"height":600,"color":"3"},
		{"id":"038591b932d2ab30","type":"text","text":"### 티맥스알지 - AI클래스: 모듈 페더레이션\n##### 상황: \n- 사용자 앱의 컴포넌트를 백오피스에서 불러와야함\n- 팀 내 아이디어는 복붙으로 하드코딩\n##### 문제\n- 하드코딩: 코드 변경이 잦은 프론트엔드에서 이는 변화에 유연하지 못함\n\t- 빌드 타임 통합은 항상 두 앱 모두 빌드가 필요함\n\t- iframe 기반 통합은 페이지 단위로만 가능\n- 모듈페더레이션은 네트워크 의존도가 생김\n- 마이크로프론트엔드 간의 스타일 충돌\n\t- 공식 문서에 따르면 스타일 마다 고유한 클래스 이름을 생성하여 중복, 중첩 문제가 없다고 한다.\n\t- 하지만 여러 앱이 독립적으로 빌드되면서 동일한 클래스네임이 생성되는 문제\n- 뷰포트와 독립적인 반응형 제어, 미디어쿼리는 실제 뷰포트 크기에 따름\n##### 해결\n- 하드코딩 -> 모듈 페더레이션을 통해 해당 컴포넌트를 내보내고 런타임에 통합\n- 네트워크 의존도 -> 에러바운더리를 사용해 에러의 전파 격리\n- 스타일 충돌 -> 바벨 플러그인으로 네임스페이스에 접두사 추가하여 스타일 격리\n- 뷰포트와 독립적인 반응형 제어 -> 재귀적으로 클래스 주입 wrapper 컴포넌트를 만들어 반응형 제어\n##### 평가\n- 실제로 얼마안가 디자인이 변경되었고, 백오피스 에서는 한줄의 코드 변경없이 그데로 기능 사용\n- 다만 배포에 의존이 생김, 만약 인터페이스가 변경되면 사용자앱 -> 백오피스 순으로 업데이트 필요\n- 인터페이스 하드코딩 -> 인터페이스도 추출하는 플러그인을 할 수 있음\n","x":160,"y":1520,"width":580,"height":600,"color":"3"},
		{"id":"6f1a13adc61c7a35","type":"file","file":"Dev/MFA (Micro Frontend Architecture).md","x":1320,"y":660,"width":580,"height":400},
		{"id":"3816a554bab5f9d8","type":"file","file":"Dev/Monorepo.md","x":1320,"y":1240,"width":580,"height":400},
		{"id":"e16d8cb2a49cbbad","type":"text","text":"### 티맥스알지 - 디지털 교과서: MFA: iFrame 기반 Shell + Nx 모노레포\n##### 상황\n- 디지털교과서 사업은 여러 팀, 회사들이 참여하여 각각의 교과목 앱들을 만드는 방식\n- 독립적인 개발-빌드-배포 생명주기를 가진 여러 앱들의 통합하는 쉘 성격의 프로젝트\n##### 문제\n- 각 팀마다 독립적인 프론트엔드 개발 환경 필요\n- 러닝커브가 낮고 단순한 통합 방법\n- 효율적인 통신 시스템\n##### 해결\n- Nx모노레포로 독립된 개발환경 구축과 공통로직 관리\n\t- Nx선정이유\n\t\t- Lerna의경우 바벨개발자에서 nx로 인수된 이후 유지보수가 활발하지 않아 기각\n\t\t- yarn workspace는 지원 기능이 가장적음 -> 단순 공통요소 공유일떄 권장\n\t\t- nx, turborepo는 모두 캐싱, 의존성 그래프 시각화 지원\n\t\t\t- 터보레포는 제로컨피그를 지향해 초기 설정 쉬움\n\t\t\t- ==상대적으로 출시된 지 오래되어 nx가 레퍼런스 많음, + IDE 플러그인==\n\t- 관련 이슈\n- iFrame기반 통합\n##### 평가\n- 각 프로젝트 별로 독립적인 환경 유지","x":160,"y":820,"width":580,"height":480,"color":"3"},
		{"id":"601f345acfe0b849","type":"text","text":"### 시프티- 코어 모듈 라이브러리 분리 및 최적화\n##### 상황:\n- 자료형 모듈과 비즈니스 로직 강결합\n- 부족한 문서화\n- **함수형을 위한 성능 오버헤드**: 뮤테이션으로 인한 복사비용, 고차함수 등\n\t- 함수형의 목적은 선언적인 작성으로 코드의 가독성과 유지보수를 높임\n\t- 하지만 코어모듈은 변경, 유지보수가 거의 없기에 성능에 초점을 맞추길 제안\n##### 문제:\n- 낮은 성능\n- 높은 결합도\n- 순환 의존성\n##### 해결:\n- 의존성 역전(DIP): 구체적인 것에 의존하지 않고 추상클래스를 중간에 두어 해결\n- 라이브러리 분리 및 문서화\n- 알고리즘 개선\n\t- 지역적 mutation 제거 O(n^2) -> O(n) [[Mutation의 개념과 활용]]\n\t- 선언적인 고차함수에서 명령형 적인 for loop 사용 [[For Loop vs Higher Order Functions]]\n\t- forEach, indexOf로 중복을 찾는 O(n^2) 걸리던 로직을 Set 자료형을 통해 O(n) 으로 개선\n##### 평가:\n- 기존 하드코딩하여 여러 프로젝트에서 사용되던 코어모듈을 중앙화된 라이브러리로 분리하여 유지보수 향상\n- 성능 최대 90%향상","x":160,"y":-1320,"width":580,"height":380,"color":"3"},
		{"id":"266014417a661a10","x":1320,"y":1800,"width":580,"height":400,"type":"file","file":"JavaScript/Module Federation.md"}
	],
	"edges":[
		{"id":"2ddf0e03ede6a064","fromNode":"e31d1d970ed7aa2a","fromSide":"right","toNode":"7f663221f77e8e83","toSide":"left"},
		{"id":"2c2998b3c8e284ed","fromNode":"7f663221f77e8e83","fromSide":"right","toNode":"2f7e9ba9e62d0666","toSide":"left"},
		{"id":"8a1880df10289423","fromNode":"e31d1d970ed7aa2a","fromSide":"right","toNode":"601f345acfe0b849","toSide":"left"},
		{"id":"15102c4ebd3308db","fromNode":"601f345acfe0b849","fromSide":"right","toNode":"62bc4b8ebec6808b","toSide":"left"},
		{"id":"ace42d6d7610339a","fromNode":"601f345acfe0b849","fromSide":"right","toNode":"0c3733d8aceb6c09","toSide":"left"},
		{"id":"277902ed8744ecb6","fromNode":"e31d1d970ed7aa2a","fromSide":"right","toNode":"e16d8cb2a49cbbad","toSide":"left"},
		{"id":"2138e7e4fa4adb3b","fromNode":"e31d1d970ed7aa2a","fromSide":"right","toNode":"038591b932d2ab30","toSide":"left"},
		{"id":"b8318809e9c39912","fromNode":"e16d8cb2a49cbbad","fromSide":"right","toNode":"6f1a13adc61c7a35","toSide":"left"},
		{"id":"c40a7b40b92ba3cc","fromNode":"e16d8cb2a49cbbad","fromSide":"right","toNode":"3816a554bab5f9d8","toSide":"left"},
		{"id":"0531d1e1de7ced88","fromNode":"038591b932d2ab30","fromSide":"right","toNode":"266014417a661a10","toSide":"left"}
	]
}