{
	"nodes":[
		{"id":"7f663221f77e8e83","type":"text","text":"### 이마고웍스 - 코드 파편화로 인한 유지보수의 어려움을 개선하기 위해 레거시 코드 리팩토링\n\n상황:\n- 서버데이터와 클라이언트 데이터의 혼용\n- 한 프로젝트에서 react-query, redux, recoil, context 등 여러 상태관리 혼용\n\n문제:\n- **일관성 부족**: 서버 데이터와 클라이언트 데이터를 혼용하면서 데이터 동기화가 어려워짐.\n- **복잡한 상태 관리**: 여러 상태 관리 라이브러리를 사용하면서 코드가 복잡해지고 유지보수가 어려워짐.\n- **예측 가능성 저하**: 특정 데이터가 어디에서 관리되고 있는지 파악하기 어려워 디버깅이 어려움.\n\n해결:\n- React-Query를 서버 상태 관리, \n- Recoil을 클라이언트 상태 관리에 집중적으로 활용하여 역할을 분리\n\t- 리코일의 쉬운 사용법과 리액트 팀에서 공식으로 만든 라이브러리이기에 채택\n\t- 쉬운 사용법은 장점이긴 하나 상태 변경 로직을 언제 어디서든 쉽게 가져다 쓸 수 있기에 여러 사람이 협업할 때 예측이 어려움\n\t\t- 이를 개선하기 위해 hooks를 거치도록 레이어를 설계\n\t\t- 전역상태의 무분별한 변경으로 인해 디버깅과 예측이 힘들어지는 것을 방지하고, 상태 변경 로직을 한 곳에 모아두기 위함\n\n평가:\n- **눈에 띄게 적어진 코드량과 낮은 러닝커브** 덕분에 생산성을 올려줌\n- **디버깅 용이**: 데이터 흐름이 명확해지고, 어디에서 상태가 변경되는지 쉽게 추적 가능.","x":160,"y":-300,"width":580,"height":880,"color":"3"},
		{"id":"2f7e9ba9e62d0666","type":"file","file":"React/Tanstack Query.md","x":1320,"y":-260,"width":580,"height":400},
		{"id":"62bc4b8ebec6808b","type":"file","file":"JavaScript/For Loop vs Higher Order Functions.md","x":1320,"y":-1360,"width":580,"height":400},
		{"id":"601f345acfe0b849","type":"text","text":"### 시프티- 코어 모듈 라이브러리 분리 및 최적화\n상황:\n- 자료형 모듈과 비즈니스 로직 강결합\n- 부족한 문서화\n- **함수형을 위한 성능 오버헤드**: 뮤테이션으로 인한 복사비용, 고차함수 등\n\t- 함수형의 목적은 선언적인 작성으로 코드의 가독성과 유지보수를 높임\n\t- 하지만 코어모듈은 변경, 유지보수가 거의 없기에 성능에 초점을 맞추길 제안\n문제:\n- 낮은 성능\n- 높은 결합도\n- 순환 의존성\n해결:\n- 의존성 역전(DIP): 구체적인 것에 의존하지 않고 추상클래스를 중간에 두어 해결\n- 라이브러리 분리 및 문서화\n- 알고리즘 개선\n\t- 지역적 mutation 제거 O(n^2) -> O(n) [[Mutation의 개념과 활용]]\n\t- 선언적인 고차함수에서 명령형 적인 for loop 사용 [[For Loop vs Higher Order Functions]]\n\t- forEach, indexOf로 중복을 찾는 O(n^2) 걸리던 로직을 Set 자료형을 통해 O(n) 으로 개선\n평가:\n- 기존 하드코딩하여 여러 프로젝트에서 사용되던 코어모듈을 중앙화된 라이브러리로 분리하여 유지보수 향상\n- 성능 최대 90%향상","x":160,"y":-1040,"width":580,"height":380,"color":"3"},
		{"id":"e31d1d970ed7aa2a","type":"file","file":"assets/박지헌_Resume_250131.pdf","x":-1200,"y":-660,"width":485,"height":660,"color":"6"},
		{"id":"2a54a434b38a6be5","type":"text","text":"#  성능최적화\n\n- 가상스크롤링\n- 초기로딩속도개선\n\t- 상호작용 시 불러오기\n\t- 트리쉐이킹\n\n최적화를 통해 얻을 수 있는 이점 ? -> 더 나은 사용자 경험과 SEO -> \n좋은 사용자 경험은 무엇일까? -> 사용자가 목적을 직관적이고 빠르게 달성\n\n\n최적화 원칙\n- 조기 최적화는 지양, 모든 최적화는 트레이드오프가 따른다.\n- 가장 좋은 코드는 실행되지 않는 코드다","x":160,"y":920,"width":625,"height":600,"color":"3"},
		{"id":"0c3733d8aceb6c09","type":"file","file":"JavaScript/Mutation의 개념과 활용.md","x":1320,"y":-850,"width":580,"height":400}
	],
	"edges":[
		{"id":"2ddf0e03ede6a064","fromNode":"e31d1d970ed7aa2a","fromSide":"right","toNode":"7f663221f77e8e83","toSide":"left"},
		{"id":"2c2998b3c8e284ed","fromNode":"7f663221f77e8e83","fromSide":"right","toNode":"2f7e9ba9e62d0666","toSide":"left"},
		{"id":"8a1880df10289423","fromNode":"e31d1d970ed7aa2a","fromSide":"right","toNode":"601f345acfe0b849","toSide":"left"},
		{"id":"15102c4ebd3308db","fromNode":"601f345acfe0b849","fromSide":"right","toNode":"62bc4b8ebec6808b","toSide":"left"},
		{"id":"ace42d6d7610339a","fromNode":"601f345acfe0b849","fromSide":"right","toNode":"0c3733d8aceb6c09","toSide":"left"}
	]
}