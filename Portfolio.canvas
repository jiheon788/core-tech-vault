{
	"nodes":[
		{"id":"e31d1d970ed7aa2a","type":"file","file":"assets/박지헌_Resume_250131.pdf","x":-700,"y":-344,"width":485,"height":660,"color":"6"},
		{"id":"2a54a434b38a6be5","type":"text","text":"#  성능최적화\n\n- 가상스크롤링\n- 초기로딩속도개선\n\t- 상호작용 시 불러오기\n\t- 트리쉐이킹\n\n최적화를 통해 얻을 수 있는 이점 ? -> 더 나은 사용자 경험과 SEO -> \n좋은 사용자 경험은 무엇일까? -> 사용자가 목적을 직관적이고 빠르게 달성\n\n\n최적화 원칙\n- 조기 최적화는 지양, 모든 최적화는 트레이드오프가 따른다.\n- 가장 좋은 코드는 실행되지 않는 코드다","x":-225,"y":900,"width":625,"height":600,"color":"3"},
		{"id":"7f663221f77e8e83","type":"text","text":"### 이마고웍스 클라우드 프로젝트 - 코드 파편화로 인한 유지보수의 어려움을 개선하기 위해 레거시 코드 리팩토링\n\n상황:\n- 서버데이터와 클라이언트 데이터의 혼용\n- 한 프로젝트에서 react-query, redux, recoil, context 등 여러 상태관리 혼용\n\n문제:\n- **일관성 부족**: 서버 데이터와 클라이언트 데이터를 혼용하면서 데이터 동기화가 어려워짐.\n- **복잡한 상태 관리**: 여러 상태 관리 라이브러리를 사용하면서 코드가 복잡해지고 유지보수가 어려워짐.\n- **예측 가능성 저하**: 특정 데이터가 어디에서 관리되고 있는지 파악하기 어려워 디버깅이 어려움.\n\n해결:\n- React-Query를 서버 상태 관리, \n- Recoil을 클라이언트 상태 관리에 집중적으로 활용하여 역할을 분리\n\t- 리코일의 쉬운 사용법과 리액트 팀에서 공식으로 만든 라이브러리이기에 채택\n\t- 쉬운 사용법은 장점이긴 하나 상태 변경 로직을 언제 어디서든 쉽게 가져다 쓸 수 있기에 여러 사람이 협업할 때 예측이 어려움\n\t\t- 이를 개선하기 위해 hooks를 거치도록 레이어를 설계\n\t\t- 전역상태의 무분별한 변경으로 인해 디버깅과 예측이 힘들어지는 것을 방지하고, 상태 변경 로직을 한 곳에 모아두기 위함\n\n평가:\n- **눈에 띄게 적어진 코드량과 낮은 러닝커브** 덕분에 생산성을 올려줌\n- **디버깅 용이**: 데이터 흐름이 명확해지고, 어디에서 상태가 변경되는지 쉽게 추적 가능.","x":160,"y":-300,"width":580,"height":880,"color":"3"},
		{"id":"2f7e9ba9e62d0666","type":"file","file":"Web/React/Tanstack Query.md","x":1200,"y":-260,"width":580,"height":400}
	],
	"edges":[
		{"id":"2ddf0e03ede6a064","fromNode":"e31d1d970ed7aa2a","fromSide":"right","toNode":"7f663221f77e8e83","toSide":"left"},
		{"id":"2c2998b3c8e284ed","fromNode":"7f663221f77e8e83","fromSide":"right","toNode":"2f7e9ba9e62d0666","toSide":"left"}
	]
}