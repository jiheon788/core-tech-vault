### Web Socket

웹소켓은 양방향 실시간 통신을 위한 프로토콜이다. http에 비해 오버헤드가 적다.

폴리싱크는 기본적으로 실시간 채팅형식의 서비스기에 웹소켓을 사용했다. 여기서 웹소켓을 편리하게 구현할 수 있게 해주는 [socket.io](http://socket.io) 라이브러리를 사용했다. 커스텀 헤더나 재연결등의 편리한 기능을 사용할 수 있다. (그런만큼 순수 웹소켓 프로토콜을 사용할때보다 오버헤드가 있다, 그렇기에 가상화폐 거래소 같은 경우에는 빠르고 비용이 적은 표준 웹소켓을 이용한다고 한다.)

##### [Socket.io](http://Socket.io) 기능

- http long polling fallback: 브라우저가 웹소켓 연결이 불가능할때 롱폴링을 사용한다
- 자동 재연결
- 패킷 버퍼링: 연결이 끊어지면 패킷들을 자동으로 버퍼에 쌓고, 재연결이 전송한다.
- 브로드캐스팅: 연결되어있는 모든 클라이언트에 한번에 이벤트 전송가능

### SSE

SSE는 클라이언트가 서버로부터 실시간 업데이트 수신할 수 있도록 하는 기술이다. 이벤트 소스를 통해 단방향으로 지속적인 데이터 수신을 한다.

AI클래스에서는 학생이 과제제출 후 교사가 채점을 완료하면 실시간으로 결과 수신이 필요했다. 양방항의 통신이 아니기에 단방향 통신인 sse를 선택했다. HTTP 프로토콜을 사용하여 간편하다.

- **Event ID 및 Last-Event-ID 헤더**
    
    SSE는 이벤트의 순서를 보장하기 위해 event ID를 사용한다. 클라이언트는 Last Event ID헤더를 통해 마지막으로 수신한 이벤트 아이디를 서버에 전달하여 연결이 재설정된 경우에도 데이터 손실없이 이어서 받을 수 있다.
    
- **Retry Mechanism**
    
    SSE는 자동으로 재연결을 시도하며 기본 재연결 간격은 3초이다.
    
- **브라우저 지원 및 폴리필**
    
    구현 브라우저에서는 SSE를 지원하지 않는 경우와, 구현 방식에 차이가 있다. 이를 해결하기 위해 폴리필 라이브러리를 사용해 호환성을 보장했다.


##### SSE 원리
1. 클라이언트가 이벤트소스 객체 생성하여 서버의 SSE 엔드포인트에 연결
2. 서버는 `Content-Type`을 `text/event-stream`으로 설정, 연결을 유지하기 위해 캐시컨트롤과 커넥션 헤더를 설정한다.
3. 서버는 필요할때 클라이언트에 이벤트 데이터 전송
4. 클라이언트는 서버로부터 이벤트를 수신하고, onmessage 핸들러를 통해 처리
5. 클로즈 메서드를 통해 연결 종료