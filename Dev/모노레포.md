![[Pasted image 20250131183700.png]]
- **모놀리스**: 소스코드의 모듈화 없이 하나의 프로젝트로 구성된 것 → 관심분리가어렵고, 개발 등의 작업이 거대해져서 비효율
- **멀티레포**: 각 모듈이 고유한 저장소를 가지는것, 역할이 잘 분리됨 → 중복코드, 고립으로 협업저하, 프로젝트생성 비효율
- **모노레포**: 각모듈이 분리되어있으나 하나의 저장소를 가짐, 기존 DevOps를 이용하여 프로젝트생성 효율, 의존성 관리 쉬움, 단일화된 관리 포인트 → 저장소 규모 증가, 의존성 충돌 및 관리 어려움
	- 적합한상황
	    - 유사한 제품의 집합
	    - 여러 프로젝트 변화를 한눈에 파악 필요
	    - 공통 기능 재사용
	    - 유사한 데브옵스 구성

### 모노레포의 역할
- 의존 관리
- 코드 공유
- 도구 통합 (린트, 포맷터, 데브옵스)

### 모노레포 관리자 종류
- **Nx**: 강력한 태스크 러너를 사용하여 빌드와 테스트를 오케스트레이션하는 동시에 모노레포에 특화된 다른 기능도 제공합니다.
- **Turborepo**: 고급 캐싱 및 태스크 파이프라이닝을 통해 기존 빌드 도구(예: npm 스크립트)의 실행을 최적화합니다.
- **pnpm workspace**: 기존 빌드 스크립트와 원활하게 통합하면서 효율적인 의존성 관리에 중점을 둡니다.


### 모노레포의 과제 극복하기
- 순환 의존성: 최신 빌드 시스템과 모노레포 관리자는 이러한 주기를 감지하고 솔루션을 제공
	- **리팩토링 가이드**: 코드 또는 종속성을 재구조화하여 순환을 끊는 방법을 제안합니다.
	- **수동 빌드 순서 지정**: 빌드 순서를 명시적으로 정의하여 종속성을 제어된 방식으로 해결할 수 있도록 합니다.
	- **의존성 반전**: 의존성 반전과 같은 디자인 패턴을 사용하여 프로젝트 간의 결합을 줄이도록 권장합니다.
- **개발자 경험(DX) 향상**: 효과적인 빌드 시스템과 모노레포 관리자는 다음을 제공하여 DX를 우선시
	- **명확한 오류 메시지**: 오류의 정확한 원인을 정확히 파악하여 실행할 수 있는 제안을 제공합니다.
	- **직관적인 인터페이스**: 간소화된 워크플로우를 위한 사용자 친화적인 명령줄 인터페이스(CLI), 시각적 도구(예: Nx Console) 또는 IDE 통합을 제공합니다.
	- **빠른 피드백 루프**: 증분 빌드 및 캐싱을 활용하여 코드 변경 사항에 대한 신속한 피드백을 제공합니다.
	- **핫 모듈 리로딩(HMR)**: 전체 페이지를 다시 로드하지 않고도 실행 중인 애플리케이션을 즉시 업데이트할 수 있어 개발 주기를 더욱 개선할 수 있습니다.
- **프로젝트 성장에 따른 확장**: 확장 문제를 해결할 수 있는 기능
	- **지능형 작업 스케줄링**: 빌드 순서를 최적화하고 독립적인 작업을 병렬화하여 빌드 시간을 단축합니다.
	- **고급 캐싱**: 중복 작업을 방지하기 위해 중간 빌드 아티팩트를 저장합니다.
	- **분산 빌드**: 대규모 프로젝트를 위해 여러 머신에 빌드를 배포합니다.
	- **코드 분할**: 대규모 애플리케이션을 더 작은 청크로 분할하여 빌드 속도를 높이고 성능을 개선합니다.
- **팀 협업 강화**:
	- 세분화된 의존성 관리
	- 병렬 개발
	- 코드리뷰 워크플로우
	- 릴리스 관리

### 모노레포의 의존성 관리: 그래프 기반 접근 방식
모노레포의 여러 프로젝트들이 서로 의존하는 경우 의존 관계가 엉키면 빌드가 느려지고 유지보수가 어려워진다. 그래서 그래프구조를 활용해 의존관게를 최적화한다.

1. 유향 비순환 그래프 (DAG)
	- "어떤 패키지가 어떤 패키지에 의존하는지"
	- 프로젝트들 간의 의존성을 표현하는 구조
	- 이를 통해 빌드 순서를 파악하고, 순환의존성을 막을 수 있다.
	- 
2. 작업 그래프 (Task Graph)
	- "어떤 작업이 어떤 순서로 실행되어야 하는지"
	- `ui-components → my-app` 이런 프로젝트 구조일때`build(ui-components) → lint(ui-components) → test(ui-components) → build(my-app) → lint(my-app) → test(my-app)` 이와 같이 작업 순서를 정할 수 있다.
	- 
3. 위상 정렬(Topological Sorting)
	- DAG를 이용해서 작업을 실행할 순서를 정하는 알고리즘









---
4. Yarn berry + workspace
    - 가장 간단해서 혼자 공부할때 써봄, 서비스 규모가 커지면 설정 추가가 까다롭다고함
    - 패키지 의존성 관리 방식: Plug’n’Play(PnP)
        - PnP는 의존성 패키지를 `node_modules` 폴더에 물리적으로 설치안한다 ⇒ 패키지 파일을 **Zip 파일 형태**로 보관 ⇒ 캐시 파일에서 필요할 때 불러와 사용
        - 프로젝트의 디스크 사용량이 줄어들고, 의존성 설치 시간이 크게 단축
5. Lerna
    - nx팀에 넘어가 더이상 유지보수 하지않는다
6. Nx
    - 원격캐싱, 의존성그래프 등 기능이 많으며 가장 안정적 → 확장성이 좋다고 판단했음
7. Turborepo
    - zero config를 지향하고 있고, 병렬 처리기법, remote caching, pipeline
    - 출시된지 비교적 최근 → 불안정하다고 판단