![[Pasted image 20250131183700.png]]
- **모놀리스**: 소스코드의 모듈화 없이 하나의 프로젝트로 구성된 것 → 관심분리가어렵고, 개발 등의 작업이 거대해져서 비효율
- **멀티레포**: 각 모듈이 고유한 저장소를 가지는것, 역할이 잘 분리됨 → 중복코드, 고립으로 협업저하, 프로젝트생성 비효율
- **모노레포**: 각 모듈이 분리되어있으나 하나의 저장소를 가짐, 기존 DevOps를 이용하여 프로젝트생성 효율, 의존성 관리 쉬움, 단일화된 관리 포인트 
	- 적합한 상황
	    - 유사한 제품의 집합
	    - 여러 프로젝트 변화를 한눈에 파악 필요
	    - 공통 기능 재사용
	    - 유사한 데브옵스 구성
	- 주의할 점
		-  저장소 규모 증가, 
		- 의존성 충돌 및 관리 어려움

### 모노레포 관리자의 역할
- 의존 관리
- 코드 공유
- 도구 통합 (린트, 포맷터, 데브옵스)

### 모노레포 관리자 종류
![[Pasted image 20250131192646.png]]
- **Nx**: 
	- 캐싱, 의존성그래프 등 가장 많은 기능 지원
		- 캐싱 기능으로 빌드 시간 감소
		- Affected 스크립트: 
			- 코드 수정시 워크스페이스의 영향 받는 부분 찾기
			- **불필요한 재빌드를 피하고, 꼭 필요한 부분만 빌드**
	- Nx 콘솔 gui툴 (vsc 확장프로그럄)
	- 스캐폴딩: 개발환경 구축, 테스트 환경 설정까지 -> 초기 모노레포 개발 환경 구축 비용 감소
	- 상대적으로 레퍼런스가 많음
- **Turborepo**: 
	- 캐싱, 의존성그래프 등 가장 많은 기능 지원
	- zero config를 지향하고 있고, 병렬 처리기법, remote caching, pipeline
- **Yarn Workspace:**
	- 다른 모노레포 도구에 비해 지원하는 것들이 많지 않아, 사용 목적이 **단순히 공통 요소를 공유**하는 것이라면 권장
	- [[Yarn#Yarn과 Yarn berry]]
- **Lerna:**
    - Bable 개발자가 만들었으나 22년 nx팀에 넘어가 더이상 유지보수 하지않는다

### 모노레포의 과제
- **순환 의존성**: 최신 빌드 시스템과 모노레포 관리자는 이러한 주기를 감지하고 솔루션을 제공
	- **리팩토링 가이드**: 코드 또는 종속성을 재구조화하여 순환을 끊는 방법을 제안합니다.
	- **수동 빌드 순서 지정**: 빌드 순서를 명시적으로 정의하여 종속성을 제어된 방식으로 해결할 수 있도록 합니다.
	- **의존성 반전**: 의존성 반전과 같은 디자인 패턴을 사용하여 프로젝트 간의 결합을 줄이도록 권장합니다.
- **개발자 경험(DX) 향상**: 효과적인 빌드 시스템과 모노레포 관리자는 다음을 제공하여 DX를 우선시
	- **명확한 오류 메시지**: 오류의 정확한 원인을 정확히 파악하여 실행할 수 있는 제안을 제공합니다.
	- **직관적인 인터페이스**: 간소화된 워크플로우를 위한 사용자 친화적인 명령줄 인터페이스(CLI), 시각적 도구(예: Nx Console) 또는 IDE 통합을 제공합니다.
	- **빠른 피드백 루프**: 증분 빌드 및 캐싱을 활용하여 코드 변경 사항에 대한 신속한 피드백을 제공합니다.
	- **핫 모듈 리로딩(HMR)**: 전체 페이지를 다시 로드하지 않고도 실행 중인 애플리케이션을 즉시 업데이트할 수 있어 개발 주기를 더욱 개선할 수 있습니다.
- **프로젝트 성장에 따른 확장**: 확장 문제를 해결할 수 있는 기능
	- **지능형 작업 스케줄링**: 빌드 순서를 최적화하고 독립적인 작업을 병렬화하여 빌드 시간을 단축합니다.
	- **고급 캐싱**: 중복 작업을 방지하기 위해 중간 빌드 아티팩트를 저장합니다.
	- **분산 빌드**: 대규모 프로젝트를 위해 여러 머신에 빌드를 배포합니다.
	- **코드 분할**: 대규모 애플리케이션을 더 작은 청크로 분할하여 빌드 속도를 높이고 성능을 개선합니다.
- **팀 협업 강화**:
	- 세분화된 의존성 관리
	- 병렬 개발
	- 코드리뷰 워크플로우
	- 릴리스 관리

### 모노레포의 의존성 관리: 그래프 기반 접근 방식
모노레포의 여러 프로젝트들이 서로 의존하는 경우 의존 관계가 엉키면 빌드가 느려지고 유지보수가 어려워진다. 그래서 그래프 기반 접근 방식을 사용하면 모노레포가 커져도 빌드를 최적화하고 유지보수를 쉽게 할 수 있게 하였다

1. 유향 비순환 그래프 (DAG)
	- "어떤 패키지가 어떤 패키지에 의존하는지"
	- 프로젝트들 간의 의존성을 표현하는 구조
	- 이를 통해 빌드 순서를 파악하고, 순환의존성을 막을 수 있다.
2. 작업 그래프 (Task Graph)
	- "어떤 작업이 어떤 순서로 실행되어야 하는지"
	- `ui-components → my-app` 이런 프로젝트 구조일때`build(ui-components) → lint(ui-components) → test(ui-components) → build(my-app) → lint(my-app) → test(my-app)` 이와 같이 작업 순서를 정할 수 있다.
3. 위상 정렬(Topological Sorting)
	- DAG를 이용해서 작업을 실행할 순서를 정하는 알고리즘
4. 순환 의존성 감지(Cycle Detection)
	- DFS 깊이 우선 탐색으로 순환 의존 탐색 -> 만약 이미 방문한 노드로 돌아오는 경우가 발생하면 순환의존성 판단
5. 도달 가능성 분석(Reachability Analysis)
	- 특정 프로젝트가 변경될 때, "어떤 프로젝트들이 영향을 받을까?"를 찾는 방법
	- 이런 분석을 통해 **불필요한 재빌드를 피하고, 꼭 필요한 부분만 빌드**
	- Nx의 `nx affected:dep-graph` 같은 기능이 바로 이걸 자동으로 찾아줌.
6. 최단 경로 알고리즘(Shortest Path Algorithm)
	- 모노레포에서는 **빌드 시간을 최소화하기 위해 중요 작업을 우선 실행하는 데 사용됨.**


### 캐시 처리
캐싱이 없으면 사소한 변경 사항이라도 변경할 때마다 프로젝트 전체 또는 상당 부분을 다시 빌드해야 하기에 빌도 속도가 저하된다. (이전 빌드의 결과를 저장하고 지능적으로 재사용함)

- 캐싱은 중복 작업을 방지하여 빌드 시간을 크게 단축할 수 있다.
- 더 빠른 빌드는 개발자에게 더 빠른 피드백 루프를 제공
- 캐싱은 계산 비용이 많이 드는 작업을 다시 실행할 필요성을 최소화하여 다른 프로세스를 위한 CPU 사이클과 메모리를 확보
- CI/CD 파이프라인에는 여러 번의 빌드와 테스트가 포함되는 경우가 많음. 캐싱은 이러한 프로세스의 속도를 크게 높여 더 빠른 릴리스와 더 빈번한 배포를 가능하게 함


---
### 참조
- 쏘카 프론트엔드 모노레포 - Part1. Code Generator로 프로젝트 세팅 자동화하기: https://tech.socarcorp.kr/fe/2024/08/29/web-monorepo-chapter-1.html
- (번역) 모노레포 인사이트: https://velog.io/@tap_kim/translate-monorepo-insights-nx-turborepo-and-pnpm
- 네이버D2 기술블로그: 모노레포 도구 비교: https://d2.naver.com/helloworld/7553804