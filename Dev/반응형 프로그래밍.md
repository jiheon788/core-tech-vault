### 등장 배경

**선언적 프로그래밍**
웹 개발에서 반응형 프로그래밍이 중요해진 계기는 웹 프레임워크로의 전환이다. 기존의 jQuery를 통해 DOM조작을 쉽게 할수 있게 도와주는 방식에서 ===웹 프레임워크를 통해 무엇을 해야할 지 선언을 해두면 내부에서 알아서 렌더링===한다.
즉, 값이 변경되었을 때 템플릿에 선언해둔대로 알아서 렌더링을 해주는 방식이 반응형 프로그래밍의 정의와 유사하다. 초기 반응형 프로그래밍은 데이터의 변경을 감지하고, 선언적으로 프로그래밍을 하는 방법을 통해 뷰를 업데이트 하는 방식으로 발전했다.

**변경사항의 전파 (pull → push)**
기존에는 렌더해야하는 시점에 필요한 데이터를 모두 불러와서 (pull)화면을 출력하는 UI 개발을 했다. 하지만 반응형 프로그래밍에서는 미리 선언된 구조에서 값이 변화할 때마다 템플릿으로 데이터를 전달 (Push)하는 방향으로 설계가 되도록 변화했다.

- **Pull(끌어오기)**: 데이터 소비자가 데이터를 요청할 때 데이터를 생성(예: 함수, Iterator) → ==Consumer가 수신 시점을 결정==
- **Push(푸시)**: 데이터 생산자가 데이터를 소비자에게 보낼 때를 결정(예: Promise, Observable). → ==Producer가 발행 시점을 결정==

**비동기 프로그래밍**
프론트엔드는 사용자를 상대하는 UI를 만들며 사용자의 동작을 예측할 수 없다. 또한 서버를 상대하는 프론트엔드는 서버의 응답이 언제, 어떻게 올 지 예측할 수 없다.

- 비동기 코드는 순서대로 동작하지 않는다
- 언제 실행될 지 예측할 수 없다.
- 호출한 순서대로 동작한다는 보장이 없다
- 호출 당시의 값과 실제 실행되었을 때의 값이 그대로 일거라는 보장이 없다.

자바스크립트의 내장 함수를 통해 비동기 함수를 동기화 할 수 있지만 **Pull 방식의 한계**로 인해 복합적인 비동기 개발의 난이도는 여전히 어렵다. 그렇기에 조금 더 간결하고 쉬운 개발을 하기 위한 관점과 체계가 필요했고 그것이 반응형 프로그래밍이다.

> 반응형 프로그래밍은 패러다임이 먼저 존재하지 않았다. 현상이 먼저 있고 그것들을 하나의 관점으로 정리한 패러다임이다.


### 반응형 프로그래밍(Reactive Programming) 개요

반응형 프로그래밍(reactive programming)은 **데이터의 변화에 즉각적으로 반응하는 프로그래밍** 패러다임이다. (데이터의 흐름과 변경사항의 전파에 중점을 둔 선언적 프로그래밍 패러다임)

주로 비동기 작업이나 이벤트 기반 프로그래밍에서 사용되며, 사용자 인터페이스(UI)와 데이터 사이의 동기화 문제를 효율적으로 해결할 수 있다. 

즉, 모든것을 스트림으로 간주하고 선언적으로 개발하는 것이 반응형 프로그래밍이다.

**Stream**
‘변할 수 있는 모든 것’은 스트림이 될 수 있다. (클릭, 호버, 변수, 사용자 입력, 데이터 구조 등등)
- 이벤트 스트림: 시간에 따라 발생하는 이벤트의 연속 (발생)
- 데이터 스트림: 시간에 따라 변화하는 데이터의 흐름 (변화)

### RxJS (Reactive Extensions for JavaScript)
RxJS는 비동기 데이터 스트림을 효과적으로 관리 하기 위해 사용한다. 데이터 스트림이란 시간에 따라 전달되는 데이터의 흐름을 의미한다. 예를 들어 클릭 이벤트, 서버응답, 사용자 입력 등 모두 데이터 스트림이 될 수 있다.

함수형 프로그래밍 스타일로 비동기 작업을 처리하며, 옵저버블, 연산자, 구독 개념을 통해 작업을 구성한다.

>[!tip]
>**리액트에서는 왜 잘 쓰이지 않을까?**
>반응형 프로그래밍의 ‘상태 변화를 관찰하고 반응하는 방식의 동작’과 리액트의 ‘컴포넌트의 상태 변화가 view에 반영되는 동작‘은 다른 개념이다. 
>- 리액트: 컴포넌트 렌더링에 중점 
>  - 반응형 프로그래밍: 이벤트 스트림에 중점

#### **Observable (관찰 가능한)**

Observable은 값을 푸시(Push-Based) 방식으로 생성하며, 지연 실행을 통해 1개의 객체에서 0개 또는 여러 값을 방출하고, 구독을 취소할 수 있다.

- Push-Based 프로듀서
- 지연 실행
- 1개의 객체에서 0 또는 여러 값을 방출 (zero or multiple values)
- 구독 취소 가능

```tsx
import { fromEvent } from 'rxjs'
const button = document.getElementById('button');

// fromEvent로 생성
const observable = fromEvent(button, 'click')

// 구독
const subscription = observable.subscribe(**event => console.log(event)**);

// 구독 해제
subscription.unsubscribe();

// new Observable로 직접 생성
const observable = new Observable(function subscribe(subscriber) {
  const id = setInterval(() => { 
    subscriber.next('hi');
  }, 1000);
});
observable.subscribe((x) => console.log(x));
```

- **생성**: `new Observable` 또는 RxJS의 `of`, `from` 같은 생성 함수로 생성.
- **구독**: `subscribe`를 호출하여 데이터 수신을 시작.
- **실행 취소**: `unsubscribe`로 실행 중단 가능.

### Observer

Observable에서 전달된 값의 소비자(Consumer)이다. next, error, complete 콜백 함수의 인터페이스를 가지며 어떻게 소비할지 명시하는 역할이다.

```tsx
// Observable에서 전달된 각 유형에 대한 콜백 인터페이스 (next, error, complete)
const observer = {
  next: x => console.log('Observer got a next value: ' + x),
  error: err => console.error('Observer got an error: ' + err),
  complete: () => console.log('Observer got a complete notification'),
};

observable.subscribe(observer); 
```

#### Subscriptions (구독)

`Subscription`은 **Observable**이 **Observer**에 데이터를 발행하도록 연결(구독)하는 과정이다. Observable은 **콜드 스트림**이므로, 구독을 통해 실제로 데이터를 발행하기 시작한다.

```tsx
// 클릭이벤트에 Observable 등록
import { fromEvent } from 'rxjs'

const button = document.getElementById('button');
const observable = fromEvent(button, 'click')

// A.subscribe(B) : A send notification to B (옵저버가 인자로 넘어감)
// 볼드 처리가 옵저버로 넘어간다 (실사용에서는 넥스트, 에러, 컴플리트 모두 넘긴다)
const subscription = observable.subscribe(**event => console.log(event)**);

// 내부적으로 옵저버를 만들고 subscriber를 넣어줌
// subscribe(observer?: PartialObserver<T>): Subscription;
// subscribe(next: (value: T) => void, error: null | undefined, complete: () => void): Subscription; 

subscription.unsubscribe();
```

#### Subscriber

Observable의 데이터를 처리하는 `Observer`의 구체적인 구현체이다.

1. Observable에서 값을 전달하는 매개체로 Subscriber가 생성되고,
2. 구독을 하면 Subscriber를 통해 값을 전달한다

```tsx
// 데이터 소스가 내부에 있음: 콜드 스트림
const observable = new Observable(subscriber => {
  console.log('Observable started');  // 2. 구독 시 발행(호출)
  subscriber.next('A'); // 매개체(subscriber)를 통해 값을 전달
  subscriber.next('B');
  subscriber.complete(); 
});

// observer.subscribe(observer)

// 1. 구독자가 정의한 콜백함수
observable.subscribe({ // 옵저버
  next: value => console.log(`Received: ${value}`),
  error: err => console.error(`Error: ${err}`),
  complete: () => console.log('Stream completed'), 
});

// Received: A
// Received: B
// Stream completed
```

#### Subject
Subject는 Observable이자 Observer 이다.

- Observable로서 데이트 스트림을 다른 Observer에게 전파 (멀티캐스트로 작동)
- 다른 Observable로부터 데이터를 받을 수 있다. (subscribe, unsubscribe)

#### Cold Stream vs Hot Stream

**Cold Stream**
- 옵저러블의 파이프라인은 새 구독자에 대해 처음부터 설정되고 각 구독자는 옵저러블의 로직에 **독립적인 실행**
- 구독 시점에 데이터 발행. 각 구독자에게 독립적 실행 (생성 → 구독 → 발행)
- 유니캐스트
- 여러 구독자가 있는 경우 동일한 계산 또는 데이터 페치를 여러 번 실행
- RxJS의 옵저버블은 기본적으로 Cold observable

**Hot Stream**
- 모든 구독자 간에 단일 실행 경로 공유, 새로운 구독자가 구독하면 기존 데이터 스트림에 가입, 파이프라인은 한번 설정되고 결과는 모든 구독자에게 브로드캐스트 됨
- 생성 시점부터 계속 데이터 발행, 구독 여부와 관계없이 실행 (생성 → 발행)
- 멀티캐스트
- **중복 계산을 피하고 싶을 때 효율적**
- 다중 구독 관계가 생기면서 구독과 해제의 관리가 주의 필요

| 특징          | **Cold Stream** | **Hot Stream**    |
| ----------- | --------------- | ----------------- |
| 데이터 발행 시점   | 구독 시 시작         | 생성 시 시작           |
| 구독자 간 실행 경로 | 독립적             | 공유                |
| 캐스팅 방식      | 유니캐스트           | 멀티캐스트             |
| 중복 계산       | 발생              | 없음                |
| 목적          | 구독자마다 독립된 결과 필요 | 데이터 공유로 효율적 처리 필요 |
