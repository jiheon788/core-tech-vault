# Monad

### Monad 정의

모나드는 ==값을 감싸는 컨테이너화==를 통해 값을 외부 접근으로부터 보호하고 연산자를 통해 접근하도록 하는 방식을 사용하는 디자인패턴이다. 모나드를 구현하여 보다 선언적인 방식으로 프로그래밍 할 수 있도록 한다.

- 수학 범주론에서 나온 개념을 프로그래밍 디자인 패턴으로 채택하여 사용한 것
- [[Fuctor]] 기반으로 구현 (flatMap 메서드 추가 제공)
- 값이 없거나 미래에 이용 가능해질 상황 등 일반적으로는 할 수 없는 여러 상황을 모델링 할 수 있다
- 비동기 로직을 동기 로직처럼 구현하면서, 함수의 합성 및 완정한 non-blocking pipeline을 구현할 수 있다.
- 추상화를 통해 값뿐만 아니라 IO, 에러와 같은 사이드 이펙트 마저 예측하고 다룬다


###### 모나드는 언제 필요한가?
- 비동기 연산 처리 -> Promise (비동기 상황을 값을 변환)
- Null 체크 단순화 -> Option
- 예외 처리
	- try-catch는 함수 합성이나 체이닝이 불가능하고 핵심로직과 부가로직이 섞여 코드를 어지럽힌다
	- 예외를 던지는 행위는 예측 가능한 값을 지양하는 참조 투명성 원리에 위배한다

### Monad 종류
- Maybe (Option)
	- 값의 존재 유무를 안전하게 다루기 위한 패턴
	- 런타임 오류를 일으키지 않고 실패를 처리하는 우아한 수단
	- 임의의 기본값을 반환하거나 오류를 던지는 것보다 나음
	- 반복되는 null 체크는 코드를 읽는 시선을 오락가락하게 만들고, 함수의 핵심동작과 부가동작을 분리하지 못함 -> 유지보수 비용증가
- List
	- 리스트에 포함된 각각의 요소에 연산을 수행하고 새로운 리스트 모나드로 반환
	- 복잡한 리스트 처리 로직을 명확하고 간결하게 표현
- Either
	- 절대로 동시에 발생하지 않는 두 값을 논리적으로 구분한 자료구조
	- e.g. Left: 에러객체 / Right: 성공한 값


>[!info] 범주론
> 범주론은 연산을 정의하는 방식이다. 집합론의 반대에 해당하는 개념으로 '요소' 대신 '요소들 간의 관계'에 주목하여 추상적인 개념들을 다루고자 하는 수학이론이다.
> - 대상(Object)보다, 대상들 사이의 관계(Morphism, Arrow)에 집중
> - 사상(Mapping)을 통해 변환을 표현하며, 모든 변환은 합성이 가능해야 함