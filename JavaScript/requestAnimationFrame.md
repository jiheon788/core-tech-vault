# requestAnimationFrame
requestAnimationFrame은 브라우저가 화면을 다시 그리기 전에 호출할 함수를 예약하는 방법입니다.

- 브라우저의 렌더링 주기에 맞추어 이벤트를 트리거하기 때문에, 모니터의 가변 주사율 이상으로 호출되지 않는다.
- ==지정된 간격에 애니메이션을 그리는게 아니라 다음 리페인트할때 예약한다.==
	- 브라우저의 상황에 맞게 동작예약
	- 비활성일때는 중지 ==(CPU 효율적으로 사용)==

**화면 갱신주기에 맞춰 실행**되므로, **1초에 60번(약 16ms마다)** 호출됩니다. 이를 통해 **CPU 자원을 아끼면서 애니메이션을 부드럽게 처리**할 수 있습니다.

디스플레이 주사율에 따라 호출 횟수 다름
- 60hz -> 1초 60번 (16ms 마다)
- 144hz -> 1초 144번




### setTimeout/setInterval의 한계
setTimeout/setInterval의 딜레이는 정확히 딜레이 시간 이후에 콜백함수 실행을 보장하지 않는다. 딜레이 시간후에 태스크 큐에 들어가는것을 보장하는 것이다.

- setTimeout 또는 setInterval은 정확한 주기마다 프레임 호출이 보장이 안된다
    - 지연 시간 이후에 콜백 함수가 태스크 큐에 푸시되어 대기하게 되지만 콜 스택이 비어야 호출
    - setInterval은 기본 딜레이 4ms
    - 브라우저는 셋타임아웃 5번이상 중첩하면 4ms의 최소 타임아웃이 강제된다. + 4ms 보다 짧을때 타이버 과부하 방지를 위해 자동으로 4ms가 된다
    - 탭이 비활성화 되면 최소 지연이 1초이상 발생한다.
- 탭이 비활성화되어도 cpu를 차지한다. → 자원낭비

위와 같은 특성들로 이벤트루프 구조상 지정된 딜레이마다 동작을 보장하지 않는다.

### 그럼 타이머 구현은 어떻게 해야할까?

1. 딜레이마다 초를 up 하는 방식이 아닌, ==타이머 시작 시간과 현재 시간을 비교하는 방식==으로 구현해야한다.
	- 타이머 시작 시간을 변수에 담아두고 interval 내에서 타이머 표기를 현재 시간과 시작 시간을 비교
2. 탭 비활성화 등 성능을 고려하면 requestAnimationFrame
	- 브라우저 렌더링 주기에 맞추어 시간 시간과 현재 시간 비교
3. 정말 계속 돌려야 하는 경우 웹 워커 사용
	- 메인 스레드와 독립된 환경에서 동작하기 때문에 탭이 숨겨져도 제한되지 않는다.