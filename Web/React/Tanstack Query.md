### 사용이유
서버의 상태는 클라이언트 상태와 본질적으로 다르다. 클라이언트의 통제를 받지않고 원격에서 API를 통해 접근/수정된다. 잘 관리하지않으면 stale한 상태가 될 수 있다. 

이전에는 상태 관리 라이브러리를 사용하여  서버데이터를 함께 관리했지만 클라이언트 상태와 서버 상태가 완전히 다르기 때문에 적합하지않다.

이러한 서버의 상태를 클라이언트와 쉽게 동기화 할 수 있도록 도와준다. (페칭, 캐싱, 동기화, 업데이트 등) 

- 서버 상태
    - 클라이언트에서 통제하거나 소유할 수 없는 위치에서 원격으로 유지
    - 가져오거나 업데이트를 위해 비동기 API가 필요
    - 주의를 기울이지 않으면 최신화되지 않은 상태를 가질 수 있다.
- 클라이언트 상태
	- 클라이언트에 의해서 제어되는 상태

### `staleTime` vs `gcTime`

각각의 설정을 통해 데이터를 더 효율적으로 관리하고, 불필요한 네트워크 요청을 줄이면서도 최신 데이터를 가져올 수 있도록 합니다.
staleTime
- 데이터가 신선한 상태로 간주하는 시간 (fresh에서 stale로 전환될 때까지의 기간)
- 쿼리가 fresh한 한, 데이터는 항상 캐시에서만 읽힙니다 (네트워크 요청은 발생x)
- 디폴트: 0 (받은 시점에서 이 데이터는 stale 하다고 간주)
###### `gcTime`
- **쿼리가 사용되지 않게 된 후에도 캐시에 유지될** 시간을 정하는 것이다
- `staleTime`이 지나면 데이터는 '오래된' 상태가 되지만, 여전히 캐시된 데이터는 사용이 가능합니다. 이 캐시 데이터는 새로운 요청을 보내 신선한 데이터를 받아오기 이전에 임시로 기존 데이터를 표시하는 데 활용됩니다.
- `gcTime`은 쿼리가 신선한 상태일때는 있을 때는 아무것도 하지 않는다. `gcTime`은 비활성화된 데이터를 gc가 언제 수집할지를 결정하는 시간이다.
- `gcTime`은 staleTime과 관계없이, 무조건 `inactive` 된 시점을 기준으로 캐시 데이터 삭제를 결정한다.
- **캐시된 데이터를 stale 상태에서도 유지**하여, 네트워크 요청이 진행되는 동안 **캐시 데이터를 즉시 렌더링할 수 있게 만드는 역할**
- 이렇게 
- 디폴트: 5분

###### `cacheTime` 이 `staleTime`보다 커야한다 ?  

만약 `staleTime`이 더 크다면,  캐싱된 데이터를 영구히 사용할 것처럼 보인다. 하지만 쿼리가 다시 활성화 될때 네트워크 요청이 필요하기에 cacheTime이 더 커야한다는 주장이다.

[TkDodo의 reply](https://github.com/TanStack/query/discussions/1685#discussioncomment-1876723)에 따르면 TkDodo는 이 의견에 동의하지 않는다고 한다. 구성 요소가 마운트되어 있는 한, `cacheTime`는 중요하지 않다. (관계없음)
예컨대, staleTime이 60분일지라도 유저가 자주 사용하지 않는 데이터라면 굳이 gcTime을 60분 이상으로 설정하여 메모리를 낭비할 필요가 없다. 

###### 최적의 staleTime, gcTime ?
리액트 쿼리를 기본 설정으로 사용하는 경우 네트워크 요청 횟수가 더 많아진다. staleTime에 어떠한 설정도 하지 않으면 해당 쿼리를 사용하는 컴포넌트(Observer)가 mount 됐을 때 매번 다시 API를 요청한다.

TkDodo는 `cacheTime`을 변경하는 경우는 거의 없었고, time 설정 중 하나를 조정하는 경우에는 보통 `staleTime`을 조정하여 해결한다고 한다.

- 변경이 자주 일어나지 않는 데이터: `staleTime`을 조정하여 불필요한 네트워크 요청 횟수 감소
- 자주 변경되는 데이터: 기본 설정을 바꾸지 않는 걸 추천 (st: 0, ct: 5m)






